/**
* Name: WasteManagement
* Based on the internal skeleton template. 
* Author: Patrick Taillandier
* Tags: 
*/
@no_experiment
model WasteManagement

import "Main model.gaml"

global {
	/******************* GEOGRAPHICAL DATA USED *************************************/
	shape_file Limites_commune_shape_file <- shape_file("../includes/Definitive_versions/Limites_communesV2.shp");

	shape_file Limites_urban_areas_shape_file <- shape_file("../includes/Definitive_versions/Limites_villagesV2.shp");

	shape_file Hydrologie_shape_file <- shape_file("../includes/Definitive_versions/Hydrology_clean2_2.shp");
	
	geometry shape <- envelope(Limites_commune_shape_file);
	
	shape_file villages_shape_file <- shape_file("../includes/Definitive_versions/Territoires_villagesV2.shp");

	shape_file Fields_shape_file <- shape_file("../includes/Definitive_versions/FieldsV1.shp");

	/*************** GENERAL PARAMETERS ON TIME AND SPACE ****************************/
	
	float step <- 1#day;// one simulation step = 1 day 
	float house_size <- 50.0 #m; // size of a house plot
	
	int end_of_game <- 8; // Number of turns of the game (1 turn = 1 year)
	float tolerance_dist <- 1#m;
	
	
	/************* PARAMETERS RELATED TO DEMOGRAPHIC AND ECONOMIC ASPECT  ***************/
	
	float budget_year_per_people <- 1.0; // total buget per year for a village (in token): number of people x budget_year_per_people
	float min_increase_urban_area_population_year <- 0.1; //min increase of urban area per year (in terms of number of people)
	
	
	/*************** PARAMETERS RELATED TO VISUALIZATION ****************************/
	
	list<rgb> village_color <- [#magenta, #gold, #violet,#orange]; // color for the 4 villages
	float min_display_waste_value <- 0.2; //just use for display all the pollution cell 
	float coeff_cell_pollution_display <- 0.01;  //coeff used to define the color of the cell according to the pollution
	float coeff_visu_canal <- 3.0;  //coeff used to define the color of the canal according to the pollution
	
	
	/********* PARAMETERS RELATED TO WATER FLOW (WASTE DIFFUSION) IN THE CANAL *******/
	
	float rate_diffusion_liquid_waste <- 10.0; //rate of liquid waste per perimeter of canals passing to the the downstream canal
	float rate_diffusion_solid_waste <- 1.0;//rate of solid waste per perimeter of canals passing to the the downstream canal
	
	
	/******* PARAMETERS RELATED TO THE IMPACT OF POLLUTION ON FIELD YIELD *************/
	
	float field_initial_productivity <- 100.0; // initial productivity of fields;
	float distance_to_canal_for_pollution_impact <- 50 #m; //all the fields at this distance are impacted by the canal pollution
	float canal_solid_waste_pollution_impact_rate <- 0.01; //production (yield) = production  - (pollution of the surrounding canal * pollution_impact_rate)
	float canal_water_waste_pollution_impact_rate <- 0.01; //production (yield) = production  - (pollution of the surrounding canal * pollution_impact_rate)
	float ground_solid_waste_pollution_impact_rate <- 0.01; //production (yield) = production  - (sum solid pollution on cell * pollution_impact_rate)
	float ground_water_waste_pollution_impact_rate <- 0.01; //production (yield) = production  - (sum water pollution on cell * pollution_impact_rate)
	
	float quantity_from_local_to_communal_landfill <- 100.0; //quantity of solid waste transfert to communal landfill every day for each local landfill 
	float quantity_communal_landfill_to_treatment <- 200.0; //quantity of solid waste "treated" (that disapears) every day from the communal landfill
	
	float local_landfill_waste_pollution_impact_rate <- 0.0001; //impact of the pollution generated by the local landfill on productivity of fields: production (yield) = production  - (pollution of the surrounding local landfill * local_landfill_waste_pollution_impact_rate)
	float communal_landfill_waste_pollution_impact_rate <- 0.0001;  //impact of pollution generated by the communal landfill on productivity of fields: production (yield) = production  - (pollution of the surrounding communal landfill * communal_landfill_waste_pollution_impact_rate)
	float distance_to_local_landfill_for_pollution_impact <- 2 #km; //distance of impact considered for the local landfills
	float distance_to_communal_landfill_for_pollution_impact <- 5 #km; //distance of impact considered for the communal landfill
	
	
	/*********** PARAMETERS RELATED TO WASTE PRODUCTION AND END OF LIFE *************/
	
	float ground_water_pollution_reducing_day <- 0.01; //quantity of the ground water pollution that disapear every day
	float ground_solid_pollution_reducing_day <- 0.001; //quantity of the solid water pollution that disapear every day
	
	float water_waste_filtering_inhabitants <- 0.2 min: 0.0 max: 1.0; // part of the water waste produced per inhabitants that are filtered
	float water_waste_year_inhabitants <- 38500.0 / 1000.0;// L/pers/year - quantity of water waste produced per people living in urban area per year 
	float solid_waste_year_inhabitants <-  220.0;//kg/pers/year - quantity of solid waste produced per people living in urban area per year  
	
	float water_waste_year_farmers <- 30000.0 / 1000.0;// L/pers/year - quantity of water waste produced per people outside  urban area (farmer) per year 
	float solid_waste_year_farmers <-  220.0;//kg/pers/year - quantity of solid waste produced per people outside  urban area (farmer) per year
	
	float part_solid_waste_canal_inhabitants <- 0.0; // proportion of solid waste throw in the canal per people living in urban area; (1 - part_solid_waste_canal_inhabitants) is throw on the ground
	float part_water_waste_canal_inhabitants <- 1.0;// proportion of water waste throw in the canal per people living in urban area; (1 - part_water_waste_canal_inhabitants) is throw on the ground
	
	float part_solid_waste_canal_farmers <- 0.5; // proportion of solid waste throw in the canal per people living outside urban area; (1 - part_solid_waste_canal_farmers) is throw on the ground
	float part_water_waste_canal_farmers <- 0.5;// proportion of water waste throw in the canal per people living outside urban area; (1 - part_water_waste_canal_farmers) is throw on the ground
	
	float part_of_water_waste_pollution_to_canal <- 0.01;// part of the water waste on ground to go the canal every day; 
	
	/********************** PARAMETERS RELATED ACTIONS ****************************/
	
	
	float token_weak_waste_collection <- 20.0; //tokens/year - cost of "weak collection"
	float token_strong_waste_collection <- 40.0; //tokens/year - cost of "strong collection"
	int collect_per_week_weak <- 2; //number of collect per week for "weak collection"
	int collect_per_week_strong <- 4; //number of collect per week for "string collection"
	float collection_team_collection_capacity_day <- 1000.0; //quantity of solid waste remove during 1 day of work
	
	
	float token_trimestrial_collective_action <- 25.0; //per year
	float impact_trimestrial_collective_action <- 0.3; //part of the solid waste remove from the canal
	
	float token_drain_dredge <- 60.0; //per action
	float impact_drain_dredge_waste <- 0.43; //part of the solid waste remove from the canal
	float impact_drain_dredge_agriculture <- 0.2; //improvment of the agricultural production
	
	float token_install_filter_for_homes_construction <- 200.0 ; //construction
	float token_install_filter_for_homes_maintenance <- 20.0 ; //per year	
	float token_sensibilization <- 15.0; //per year
	
	float token_pesticide_reducing <- 30.0; //per year
	float impact_pesticide_reducing_production  <- 0.15; //decrease of the agricultural production
	float impact_pesticide_reducing_waste  <- 0.33; //decrease waste production from farmers
	
	float token_implement_fallow <- 25.0; //per year
	float impact_implement_fallow  <- 0.33; //decrease the agricultural production
	
	float token_support_manure_buying <- 30.0; //per year
	float impact_support_manure_buying_production  <- 0.15; //improvment of the agricultural production
	float impact_support_manure_buying_waste  <- 0.2; //increase wastewater production
	
	float token_installation_dumpholes <- 15.0; //per year
	float impact_installation_dumpholes  <- 0.25; //decreasse
	

	/********************** CONSTANTS ****************************/
		
	string PLAYER_TURN <- "player turn";
	string COMPUTE_INDICATORS <-  "compute indicators";
	
	string ACT_DRAIN_DREDGE <- "Drain and dredge";
	string ACT_FACILITY_TREATMENT <- "Install water treatment facilities for every home";
	string ACT_SENSIBILIZATION <- "Organise sensibilization about waste sorting workshops in schools";
	string ACTION_COLLECTIVE_ACTION <- "Trimestrial collective action";
	string ACT_PESTICIDE_REDUCTION <- "Help farmers to reduce pesticides use";
	string ACT_SUPPORT_MANURE <- "Help farmer buy manure";
	string ACT_IMPLEMENT_FALLOW <- "Put part of the fields in fallow ";
	string ACT_INSTALL_DUMPHOLES <- "Making farmers participate in the installation of dumpholes for agricultural products";
	string ACT_END_OF_TURN <- "end of turn";
	
	
	
	/********************** INTERNAL VARIABLES ****************************/
	
	bool without_player <- false; //for testing
	 
	string stage <-COMPUTE_INDICATORS;
	
	int index_player <- 0;
	date computation_end;
	
	int action_type <- -1;	
	
	communal_landfill the_communal_landfill;
	
	list<string> actions_name <- [
		ACT_DRAIN_DREDGE,
		ACT_FACILITY_TREATMENT,
		ACT_SENSIBILIZATION,
		ACTION_COLLECTIVE_ACTION,
		ACT_PESTICIDE_REDUCTION,
		ACT_SUPPORT_MANURE,
		ACT_IMPLEMENT_FALLOW,
		ACT_INSTALL_DUMPHOLES,
		ACT_END_OF_TURN
	]; 
	
	
	int turn <- 0;
	
	
	/********************** INITIALIZATION OF THE GAME ****************************/

	init {
		create village from: villages_shape_file sort_by (location.x + location.y * 2);
		
		do create_canals;
		
		create commune from: Limites_commune_shape_file;
		
		do create_urban_area;
		
		do create_plots;
	
		do create_communal_landfill;
		
		do init_villages;	
		
		ask cell {do update_color;}
		
		computation_end <- current_date add_years 1;
	}
	
		
	
	action create_canals {
		create canal from: Hydrologie_shape_file with: (width:float(get("WIDTH")));	 
		
		graph canal_network <- directed(as_edge_graph(canal));
		ask canal {
			downtream_canals<- list<canal>(canal_network out_edges_of (canal_network target_of self));	
		}
		
		ask cell {
			using topology (world) {
				closest_canal <- canal closest_to location;
			}
		}
	}
	
	action create_urban_area {
		create urban_area from: Limites_urban_areas_shape_file;
		ask urban_area {
			list<geometry> geoms <- to_squares (shape,house_size);
			float nb <- 0.0;
			create house from: geoms {
				create inhabitant {
					location <- myself.location;
					my_house <- cell(location);
					my_cells <- cell overlapping myself;
					closest_canal <- canal closest_to self;
					nb <- nb + nb_people;
				}
			}
			population <- nb;
		
		} 
		
	}
	
	action create_communal_landfill {
		create communal_landfill {
			shape <- square(200) ;
			location <- any_location_in(first(commune).shape.contour);
			the_communal_landfill <- self;
		}
	}
	
	action create_plots {
		create plot from: Fields_shape_file {
			geometry g <- shape + tolerance_dist;
			list<canal> canals <- canal overlapping g;
			if empty(canals) {
				closest_canal <- canal closest_to self;
			} else {
				if length(canals) = 1 {closest_canal <- first(canals);}
				else {
					closest_canal <- canals with_max_of (g inter each).perimeter;
				}
				perimeter_canal_nearby <- (g inter closest_canal).perimeter;
			}
			my_cells <- cell overlapping self;
			
			the_village <- village closest_to self;
			create farmer {
				myself.the_farmer <- self;
				closest_canal <- myself.closest_canal;
				location <- myself.location;
				my_house <- cell(location);
				my_cells <- myself.my_cells;	
			}
			the_communal_landfill <- first(communal_landfill at_distance distance_to_communal_landfill_for_pollution_impact);
			the_local_landfill <- first(local_landfill at_distance distance_to_local_landfill_for_pollution_impact);
		 	impacted_by_canal <- (self distance_to closest_canal) <= distance_to_canal_for_pollution_impact;
		}
		
	}
	
	action init_villages {
		ask village {
			plots <- plot overlapping self;
			cells <- cell overlapping self;
			canals <- canal at_distance 1.0;
			inhabitants <- (inhabitant overlapping self) + (farmer overlapping self);
			population <- inhabitants sum_of each.nb_people;
			
			ask urban_area overlapping self {
				my_villages << myself;
			}
			create collection_team with:(my_village:self) {
				myself.collection_teams << self;
			}
			create local_landfill with:(my_village:self){
				
				location <- any_location_in(myself);
				myself.my_local_landfill <- self;
			}
		} 
	}
	action activate_act1 {
		ask village[index_player] {do drain_dredge;}
	}
	action activate_act2 {
		ask village[index_player] {do install_facility_treatment_for_homes;}
	}
	action activate_act3 {
		ask village[index_player] {do sensibilization;}
	}
	action activate_act4 {
		ask village[index_player] {do trimestrial_collective_action;}
	}
	action activate_act5 {
		ask village[index_player] {do pesticide_reducing;}
	}
	action activate_act6 {
		ask village[index_player] {do support_manure_buying;}
	}
	action activate_act7 {
		ask village[index_player] {do implement_fallow;}
	}
	action activate_act8 {
		ask village[index_player] {do install_gumpholes;}
	}
	action activate_act9 {
		ask village[index_player] {do end_of_turn;}
	}
	action activate_act {
		if stage = PLAYER_TURN {
			button selected_but <- first(button overlapping (circle(1) at_location #user_location));
			if(selected_but != nil) {
				ask selected_but {
					ask button {bord_col<-#white;}
					if (action_type != id) {
						action_type<-id;
						bord_col<-#red;
						ask myself {do act_management();}
					} else {
						action_type<- -1;
					}
					
				}
			}
		}
	}
	
	action act_management {
		switch action_type {
			match 2 {ask village[index_player] {do end_of_turn;}}
		}
	}
	
	action manage_flow_canal {
		ask canal {
			do init_flow;
		}
		ask canal {
			do flow;
		}
		ask canal {
			do update_waste;
		}	
	}
	
	action manage_individual_pollution {
		ask farmer + inhabitant{
			do domestic_waste_production;
		}
		ask plot {
			do pollution_due_to_practice;
		}
	}
	
	action manage_daily_indicator {
		ask plot {
			do compute_productivity;
		}
		
		ask cell {
			do update_color;
		}
		ask village {do compute_indicators;}
	}
	
	action manage_landfill {
		ask local_landfill {
			do transfert_waste_to_communal_level;
		}
		ask communal_landfill {
			do manage_waste;
		}
	}
	
	action manage_end_of_indicator_computation {
		if (current_date >= computation_end) {
			stage <- PLAYER_TURN;
			index_player <- 0;
			step <- 0.0001;
			ask village {
				budget <- budget_year_per_people * population;
			}
			ask village {
				actions_done <- [];
				is_drained <- false;
			}
			turn <- turn + 1;
			if turn >= end_of_game {
				do pause;
			}
			else if not without_player {
				do tell("PLAYER TURN");
				ask village[0] {do start_turn;}
			}
		
			
		}
	}
	
	action manage_pollution_decrease {
		ask cell {
			do natural_pollution_reduction;
		}
		ask collection_team {
			do collect_waste;
		}
	}
	
	action increase_urban_area {
		using topology(world) {
			ask urban_area {
				list<plot> neighbors_plot <- plot at_distance 0.1;
				if not empty(neighbors_plot) {
					float target_pop <- population *(1 + min_increase_urban_area_population_year);
					loop while: not empty(neighbors_plot) and population <target_pop {
						plot p <- one_of(neighbors_plot);
						p >> neighbors_plot;
						if (dead(p)) {break;}
						geometry shape_plot <- copy(p.shape);
						ask my_villages {inhabitants >> p.the_farmer; plots >> p;}
						shape <- shape + shape_plot;
						ask p.the_farmer {do die;}
						ask p {do die;}
						list<geometry> geoms <- to_squares (p,house_size);
						float nb <- 0.0;
						create house from: geoms {
							create inhabitant {
								location <- myself.location;
								my_house <- cell(location);
								my_cells <- cell overlapping myself;
								closest_canal <- canal closest_to self;
								nb <- nb + nb_people;
							}
						}
						population <- population + nb;
						
					}
				}
			}
			
		}
	}
	
	reflex indicators_computation when: stage = COMPUTE_INDICATORS {
		do manage_individual_pollution;
		do manage_flow_canal;
		do manage_pollution_decrease;
		do manage_landfill;
		do manage_daily_indicator;
		do manage_end_of_indicator_computation;
	}
	
	reflex playerturn when: stage = PLAYER_TURN{
		if without_player or index_player >= length(village) {
			stage <- COMPUTE_INDICATORS;
			current_date <- computation_end;
			computation_end <- computation_end add_years 1;
			step <- #day;
			
			if not without_player {do tell("INDICATOR COMPUTATION");}
			do increase_urban_area;
		}
	}
	

}


grid button width:3 height:3 
{
	int id <- int(self);
	rgb bord_col<-#white;
	list<string> to_display_text;
	int threshold_cut <- 15;
	init {
		string to_display <- actions_name[id];
		int cpt <-0;
		list<string> dd <- to_display split_with " ";
		string current_line <- "";
		loop d over: dd {
			current_line <- current_line + " " + d;
			if length(current_line) > threshold_cut {
				to_display_text << copy(current_line);
				current_line <- "";
			}
		}
		to_display_text << copy(current_line);
				
	}
	aspect normal {
		draw rectangle(shape.width * 0.8,shape.height * 0.8).contour + (shape.height * 0.01) color: bord_col;
		loop i from: 0 to: length(to_display_text) -1 {
			draw to_display_text[i] font: font("Helvetica", 13 , #bold) anchor:#center color: #white at: {location.x, location.y - 500 + 200 * i};
		}
	
	}
}



grid cell height: 50 width: 50 {
	float solid_waste_level <- 0.0 min: 0.0;
	float water_waste_level <- 0.0 min: 0.0;
	float pollution_level <- 0.0;
	canal closest_canal;
	
	action natural_pollution_reduction {
		if solid_waste_level > 0 {
			solid_waste_level <- solid_waste_level - ground_solid_waste_pollution_impact_rate;
		}
		if water_waste_level > 0 {
			water_waste_level <- water_waste_level - ground_water_waste_pollution_impact_rate;
			float to_canal <- water_waste_level * part_of_water_waste_pollution_to_canal;
			closest_canal.water_waste_level <- closest_canal.water_waste_level + to_canal;
			water_waste_level <- water_waste_level - to_canal;
		}
	}
	action update_color {
		pollution_level <- (water_waste_level + solid_waste_level) * coeff_cell_pollution_display;
		color <- rgb(255 * pollution_level, 255 * (1.0 - pollution_level),  0);
	} 
	
	aspect default {
		if pollution_level > min_display_waste_value {
			draw shape color: color;
		}
	}
	
}

species village {
	rgb color <- village_color[int(self)];
	list<string> actions_done;
	list<cell> cells;
	list<canal> canals;
	list<inhabitant> inhabitants;
	local_landfill my_local_landfill;
	float budget;
	float solid_pollution_level ;
	float water_pollution_level;
	float productivity_level min: 0.0;
	list<collection_team> collection_teams;
	float bonus_agricultural_production;
	list<plot> plots;
	float population;
	bool is_drained <- false;
	bool weak_collection_policy;
	
	
	action compute_indicators {
		solid_pollution_level <- ((cells sum_of each.solid_waste_level) + (canals sum_of (each.solid_waste_level))) / 10000.0;
		water_pollution_level <- ((cells sum_of each.water_waste_level) + (canals sum_of (each.water_waste_level)))/ 10000.0;
		plots <- plots where not dead(each);
		productivity_level <- (plots sum_of each.current_productivity) / length(plots) / 100.0;
	}

	
	
	//1:ACT_DRAIN_DREDGE
	action drain_dredge {
		if budget >= token_drain_dredge {
			bool  is_ok <- user_confirm("Action Drain & Dredge","PLAYER " + (index_player + 1) +", do you confirm that you want to " + ACT_DRAIN_DREDGE + "?");
			if is_ok {
				is_drained <- true;
				ask canals {
					solid_waste_level <- solid_waste_level * (1 - impact_drain_dredge_waste);
				}
				budget <- budget - token_drain_dredge;
			}
		} else {
			do tell("Not enough budget for " +ACT_DRAIN_DREDGE );
		}
	}
	
	//2:ACT_FACILITY_TREATMENT
	action install_facility_treatment_for_homes {
		if budget >= token_install_filter_for_homes_construction {
			bool  is_ok <- user_confirm("Action Facility treatment","PLAYER " + (index_player + 1) +", do you confirm that you want to " + ACT_FACILITY_TREATMENT + "?");
			if is_ok {
				budget <- budget - token_install_filter_for_homes_construction;
			}
		}else {
			do tell("Not enough budget for " +ACT_FACILITY_TREATMENT );
		}
	}
	
	//3:ACT_SENSIBILIZATION
	action sensibilization {
		if budget >= token_sensibilization {
			bool  is_ok <- user_confirm("Action Sensibilization","PLAYER " + (index_player + 1) +", do you confirm that you want to " + ACT_SENSIBILIZATION + "?");
			if is_ok {
				budget <- budget - token_sensibilization;
			}
		}else {
			do tell("Not enough budget for " +ACT_SENSIBILIZATION );
		}
	}
	
	//4:ACTION_COLLECTIVE_ACTION
	action trimestrial_collective_action {
		if budget >= token_trimestrial_collective_action {
			bool  is_ok <- user_confirm("Action trimestrial action","PLAYER " + (index_player + 1) +", do you confirm that you want to " + ACTION_COLLECTIVE_ACTION + "?");
			if is_ok {
				ask canals {
					solid_waste_level <- solid_waste_level * (1 - impact_trimestrial_collective_action);
				}
				budget <- budget - token_trimestrial_collective_action;
			}
		} else {
			do tell("Not enough budget for " +ACTION_COLLECTIVE_ACTION );
		}
		
	}
	
	//5:ACT_PESTICIDE_REDUCTION
	action pesticide_reducing {
		if budget >= token_pesticide_reducing {
			bool  is_ok <- user_confirm("Action Pesticide reducing","PLAYER " + (index_player + 1) +", do you confirm that you want to " + ACT_PESTICIDE_REDUCTION + "?");
			if is_ok {
				budget <- budget - token_pesticide_reducing;
			}
		}else {
			do tell("Not enough budget for " +ACT_PESTICIDE_REDUCTION );
		}
	}
	
	//6:ACT_SUPPORT_MANURE
	action support_manure_buying {
		if budget >= token_support_manure_buying {
			bool  is_ok <- user_confirm("Action Support Mature","PLAYER " + (index_player + 1) +", do you confirm that you want to " + ACT_SUPPORT_MANURE + "?");
			if is_ok {
				budget <- budget - token_support_manure_buying;
			}
		}else {
			do tell("Not enough budget for " +ACT_SUPPORT_MANURE );
		}
	}
	
	
	//7:ACT_IMPLEMENT_FALLOW
	action implement_fallow {
		if budget >= token_implement_fallow {
			bool  is_ok <- user_confirm("Action Implementation Follow","PLAYER " + (index_player + 1) +", do you confirm that you want to " + ACT_IMPLEMENT_FALLOW + "?");
			if is_ok {
				budget <- budget - token_implement_fallow;
			}
		}else {
			do tell("Not enough budget for " +ACT_IMPLEMENT_FALLOW );
		}
	}
	
	
	//8:ACT_INSTALL_DUMPHOLES,
	action install_gumpholes {
		if budget >= token_installation_dumpholes {
			bool  is_ok <- user_confirm("Action Installation Dumpholes","PLAYER " + (index_player + 1) +", do you confirm that you want to " + ACT_INSTALL_DUMPHOLES + "?");
			if is_ok {
				budget <- budget - token_installation_dumpholes;
				ask plot {
					
				}
			}
			
		}else {
			do tell("Not enough budget for " +ACT_INSTALL_DUMPHOLES );
		}
	}
	
	//9:ACT_END_TURN,
	action end_of_turn {
		bool  is_ok <- user_confirm("End of turn","PLAYER " + (index_player + 1) +", do you confirm that you want to end the turn?");
		if is_ok {
			index_player <- index_player + 1;
			if index_player < length(village) {
				ask village[index_player] {
					do start_turn;
				}
			}
		}
	}
	
	action start_turn {
		do tell("PLAYER " + (index_player + 1) + " TURN");
		string current_val <- "" +(weak_collection_policy ? collect_per_week_weak : collect_per_week_weak) + " per week";
		map result <- user_input_dialog("PLAYER " + (index_player + 1)+" - Choose a waste collection team policy",[choose("frenquency",string,current_val, [""+collect_per_week_weak +" per week",""+collect_per_week_strong +" per week"])]);
		weak_collection_policy <- result["frenquency"] = ""+collect_per_week_weak +" per week";
		budget <- budget - (weak_collection_policy ? token_weak_waste_collection : token_strong_waste_collection);
		
	}
	aspect default {
		if (stage = PLAYER_TURN) {
			if (index_player = int(self)) {
				draw shape color: color;
			}
		} else {
			
			draw shape.contour + 20.0 color: color;
		}
	}
}

species plot {
	village the_village;
	float base_productivity <- field_initial_productivity min: 0.0;
	float current_productivity min: 0.0;
	float pratice_water_pollution_level;
	float part_to_canal_of_pollution;
	canal closest_canal;
	farmer the_farmer;
	list<cell> my_cells;
	communal_landfill the_communal_landfill;
	local_landfill the_local_landfill;
	bool impacted_by_canal <- false;
	float perimeter_canal_nearby;
	
	action pollution_due_to_practice { 
		if pratice_water_pollution_level > 0 {
			float to_the_canal <- pratice_water_pollution_level * part_to_canal_of_pollution;
			float to_the_ground <- pratice_water_pollution_level - to_the_canal;
			if to_the_canal > 0 {
				closest_canal.water_waste_level <- closest_canal.water_waste_level + to_the_canal;
			}
			if to_the_ground > 0 {
				ask my_cells {
					water_waste_level <- water_waste_level + to_the_ground  ;
				}
			}
		}
		
	}
	

	action compute_productivity {
		current_productivity <- base_productivity;
		if the_village.is_drained {
			current_productivity <- current_productivity * (1 + impact_drain_dredge_agriculture);
		}
		if (the_local_landfill != nil) {
			current_productivity <- current_productivity - the_local_landfill.waste_quantity * local_landfill_waste_pollution_impact_rate;
		}
		if (the_communal_landfill != nil) {
			current_productivity <- current_productivity - the_communal_landfill.waste_quantity * communal_landfill_waste_pollution_impact_rate;
		}
		float solid_ground_pollution <- my_cells sum_of each.solid_waste_level;
		if (solid_ground_pollution > 0) {
			current_productivity <- current_productivity - solid_ground_pollution * ground_solid_waste_pollution_impact_rate;
		}
		float water_ground_pollution <- my_cells sum_of each.water_waste_level;
		if (solid_ground_pollution > 0) {
			current_productivity <- current_productivity - water_ground_pollution * ground_water_waste_pollution_impact_rate;
		}
		if impacted_by_canal {
			current_productivity <- current_productivity - closest_canal.solid_waste_level * canal_solid_waste_pollution_impact_rate; 
			current_productivity <- current_productivity - closest_canal.water_waste_level * canal_water_waste_pollution_impact_rate; 
		}
	}
	
	aspect default {
		draw shape color: #green border: #black;
	}
}

species urban_area {
	float population;
	list<village> my_villages;
}
species house {
	aspect default {
		draw shape color: #gray border: #black;
	}
}
species canal {
	float width;
	float solid_waste_level min: 0.0;
	float water_waste_level min: 0.0;
	float solid_waste_level_tmp;
	float water_waste_level_tmp;
	list<canal> downtream_canals;
	
	
	action init_flow {
		solid_waste_level_tmp <- 0.0;
		water_waste_level_tmp <- 0.0;
	}
	action flow {
		
		float to_diffuse_solid <-  solid_waste_level / shape.perimeter  * rate_diffusion_solid_waste  ; 
		float to_diffuse_water <-  water_waste_level / shape.perimeter  * rate_diffusion_liquid_waste ; 
		
		int nb <- length(downtream_canals);
		if nb > 0 {
			ask downtream_canals {
				solid_waste_level_tmp <- solid_waste_level_tmp + to_diffuse_solid/ nb;
				water_waste_level_tmp <- water_waste_level_tmp +to_diffuse_water  / nb;
			}
		}
		solid_waste_level_tmp <- solid_waste_level_tmp - to_diffuse_solid ;
		water_waste_level_tmp <-  water_waste_level_tmp - to_diffuse_water;
	}
	action update_waste {
		solid_waste_level <- solid_waste_level + solid_waste_level_tmp;
		water_waste_level <- water_waste_level + water_waste_level_tmp ;
	}
	aspect default {
		draw shape  + (width +3) color: blend(#red,#blue,(solid_waste_level+water_waste_level)/shape.perimeter / coeff_visu_canal);
	}
}

species commune {
	rgb color <- #pink;
	aspect default {
		draw shape color: color;
	}
}

species local_landfill {
	village my_village;
	float waste_quantity;
	
	aspect default {
		draw circle(50) depth: waste_quantity / 100.0 border: #blue color: #red;
	}
		
	action transfert_waste_to_communal_level {
		if waste_quantity > 0 {
			float to_transfert <- min(quantity_from_local_to_communal_landfill, waste_quantity);
			the_communal_landfill.waste_quantity <- the_communal_landfill.waste_quantity + to_transfert;
			waste_quantity <- waste_quantity - to_transfert;
		}
		
	}
}

species communal_landfill {
	float waste_quantity min: 0.0;
	
	aspect default {
		draw circle(200) depth: waste_quantity / 100.0 border: #blue color: #red;
	}
	
	action manage_waste {
		if waste_quantity > 0 {
			waste_quantity <- waste_quantity - quantity_communal_landfill_to_treatment;
		}
		
	}
}

species farmer parent: inhabitant {
	rgb color <- #yellow;
	float max_agricultural_waste_production <- rnd(1.0, 3.0);
	float solid_waste_day <- nb_people * solid_waste_year_farmers / 365;
	float water_waste_day <- nb_people * water_waste_year_farmers / 365;
	float part_solid_waste_canal <- part_solid_waste_canal_farmers;
	float part_water_waste_canal <- part_water_waste_canal_farmers;
}
species inhabitant {
	rgb color <- #red;
	cell my_house;
	canal closest_canal;
	float nb_people <- 1.0;
	float water_filtering <-water_waste_filtering_inhabitants;
	float solid_waste_day <- nb_people * solid_waste_year_inhabitants / 365;
	float water_waste_day <- nb_people * water_waste_year_inhabitants / 365;
	float part_solid_waste_canal <- part_solid_waste_canal_inhabitants;
	float part_water_waste_canal <- part_water_waste_canal_inhabitants;
	list<cell> my_cells;
	aspect default {
		draw circle(10.0) color: color;
	}
	
	action domestic_waste_production {
		if solid_waste_day > 0 {
			float to_the_canal <- solid_waste_day * part_solid_waste_canal;
			float to_the_ground <- solid_waste_day - to_the_canal;
			if to_the_canal > 0 {
				closest_canal.solid_waste_level <- closest_canal.solid_waste_level + to_the_canal;
			}
			if to_the_ground > 0 {
				ask one_of(my_cells) {
					solid_waste_level <- solid_waste_level + to_the_ground ;
				}
			}
		}
		if water_waste_day > 0 {
			float w <- (1 - water_filtering) * water_waste_day;
			float to_the_canal <- w * part_water_waste_canal ;
			float to_the_ground <- w - to_the_canal;
			
			if to_the_canal > 0 {
				closest_canal.water_waste_level <- closest_canal.water_waste_level + to_the_canal;
			}
			if to_the_ground > 0 {
				ask one_of(my_cells) {
					water_waste_level <- water_waste_level + to_the_ground ;
				}
			}
			
		}	
	}
}

species collection_team {
	rgb color <- #gold;
	int nb_collection_week <-collect_per_week_weak;
	float collection_capacity <- collection_team_collection_capacity_day;
	village my_village;
	
	
	action collect_waste {
		float waste_collected <- 0.0;
		loop while: waste_collected < collection_capacity  {
			list<cell> cells_to_clean <-  my_village.cells where (each.solid_waste_level > 0);
			if  empty(cells_to_clean) {
				break;
			}
			else {
				cell the_cell <- cells_to_clean with_max_of (each.solid_waste_level);
				ask the_cell{
					float w <- min(myself.collection_capacity - waste_collected, solid_waste_level);
					waste_collected <- waste_collected + w;
					solid_waste_level <- solid_waste_level  - w;
				}
			}
		}
		ask my_village.my_local_landfill {
			waste_quantity <- waste_quantity + waste_collected;
		}
	}
}
